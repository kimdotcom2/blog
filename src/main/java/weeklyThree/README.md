# 위클리 페이퍼 3

## HashSet의 내부 동작 방식과 중복 제거 메커니즘을 설명하고, HashSet이 효율적인 중복 체크를 할 수 있는 이유를 설명해주세요.

HashSet는 내부적으로 HashMap을 사용해 중복을 체크한다.

HashMap<K, V>에서 K에 Set에 들어갈 값을, V에는 더미 객체를 넣는다.

그리고 Set에 새로운 객체가 들어오면 containsKey()를 통해 객체가 이미 존재하는지 확인한다.

HashSet은 HashMap과 마찬가지로 hashCode()를 사용해 Key 값의 해시값을 구한다. 

해시값을 인덱스로 하여 버킷(해시 테이블)에 해당 객체가 존재하는지를 찾는다. 만약 객체가 존재하면 중복 처리한다.

인덱스가 존재하지 않는다면 버킷에 인덱스와 더미 객체를 추가한다. 충돌 발생시 LinkedList로 체이닝 하거나 테이블을 재배열한다.

이 모든 과정의 시간복잡도는 O(1)이다.

## O(n)과 O(log n)의 성능 차이를 실생활 예시를 들어 설명하고, 데이터의 크기가 1백만 개일 때 각각 대략 몇 번의 연산이 필요한지 비교해주세요.

### O(n)의 시간 복잡도를 가질 떄 1백만 개의 데이터를 넣을때

정렬되지 않은 1백만 개의 책이 보관된 도서관에서 내가 원하는 책을 찾으려 한다.

직접 책의 제목을 비교하는 방법밖에 없기 때문에 최악의 경우, 1백만번 책을 꺼내 비교하여 찾아야 한다.

### O(log n)의 시간 복잡도를 가질 떄 1백만 개의 데이터를 넣을때

1부터 n까지의 숫자 중 미리 정해둔 숫자를 맞추는 게임을 하려 한다. 임의의 숫자 m을 제시해 3개의 질문을 할 수 있다.

1) 정답은 m보다 큰 수인가?
2) 정답은 m보다 작은 수인가?
3) m은 정답인가?

최솟값(1)과 최댓값(n)의 중간값을 m으로 하여 질문한다.

만약 m이 정답보다 작다면 m을 최댓값으로 한다.

만약 m이 정답보다 크다면 m을 최솟값으로 한다.

그렇게 범위를 절반씩 줄이며 이진 탐색을 하여 최솟값과 최댓값의 범위를 좁혀 더 이상 좁힐 수 없을 떄, m은 정답이다.

만약 n이 1백만이라면 2^20 = 1048576이므로 20번의 연산이 필요하다.

# 위클리 페이퍼 9

## JPA에서 발생하는 N+1 문제의 발생 원인과 해결 방안에 대해 설명하세요.

JPA(Java Persistence API)에서 N+1 문제는 데이터베이스에서 연관된 엔티티를 조회할 때 발생하는 성능 문제이다.

JPA를 통해 엔티티를 조회할 때, 해당 엔티티에 연관된 N개의 엔티티를 각각 별도의 쿼리로 조회하는 상황이 발생할 수 있다. 

예를 들어, 게시글(Post) 엔티티를 조회할 때 각 게시글에 연관된 댓글(Comment) 엔티티를 함께 조회하려고 하면, 
처음에 게시글을 조회하는 1개의 쿼리와 각 게시글마다 댓글을 조회하는 N개의 쿼리가 실행되어 총 N+1개의 쿼리가 발생하게 된다. 

이로 인해 데이터베이스에 불필요한 부하가 발생하고 성능 저하가 일어날 수 있다.

이 문제는 연관 관계 조회 전략이 즉시 로딩이냐 지연 로딩이냐에 상관없이 발생할 수 있다.
단지 언제 연관 관계를 조회하냐의 차이일 뿐이다.

해당 문제의 근본적 원인은 ORM과 관계형 데이터베이스 간의 패러다임이 다르기 때문이다.

DBMS는 SQL을 통해 한 번의 조인 쿼리로 여러 테이블의 데이터를 한꺼번에 조회할 수 있다.

ORM은 테이블을 객체로 매핑하고, 객체 그래프를 통해 연관된 데이터를 탐색하는 방식을 사용한다.
그리고 객체 그래프 탐색 시점에 연관된 데이터를 조회하는 쿼리를 별도로 실행한다.

둘은 추구하는 방식이 다르기 때문에 N+1 문제가 발생할 수밖에 없다.

### 해결책

JPQL에서 fetch join을 사용하여 연관된 엔티티를 한 번의 쿼리로 함께 조회할 수 있다. 
이를 통해 N+1 문제를 해결할 수 있다.
   
방법

1. JPQL을 사용하여 명시적으로 fetch join을 작성한다.
2. @EntityGraph 어노테이션을 사용하여 연관된 엔티티를 함께 로드하도록 지정한다.
3. QueryDSL을 사용하는 경우 fetch join을 활용하여 연관된 엔티티를 함께 조회한다.

단 연관 관계가 1:N, N:M인 경우에는 데이터 중복이 발생할 수 있으므로 페이징 처리에 주의해야 한다.

Batch Size 기능을 활용하여 연관된 엔티티를 나눠서 조회하여 어느 정도 성능을 향상할 수 있다.

어떤 경우에는 의도적으로 N+1 문제를 허용하는 것이 더 나은 선택일 수 있다.


## 트랜잭션의 ACID 속성 중 격리성(Isolation)이 보장되지 않을 때 발생할 수 있는 문제점들을 설명하고, 이를 해결하기 위한 트랜잭션 격리 수준들을 설명하세요.

DBMS는 정합성을 보장하기 위해 트랜잭션의 격리 수준을 설정할 수 있다.

1. Read Uncommitted(읽기 미완료): 가장 낮은 격리 수준으로, 한 트랜잭션이 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있다. 
이로 인해 트랜잭션에서 수정한 데이터가 커밋되지 않은 상태에서 다른 트랜잭션이 해당 데이터를 읽어 Dirty Read 문제가 발생할 수 있다.
사실상 격리성이 보장되지 않는다.

2. Read Committed(읽기 완료): 한 트랜잭션이 커밋된 데이터만 다른 트랜잭션이 읽을 수 있다.
이로 인해 더티 리드는 방지되지만, 한 트랜잭션이 데이터를 읽은 후 다른 트랜잭션이 해당 데이터를 수정하고 커밋할 수 있다.
따라서 같은 데이터를 두 번 읽었을 때 서로 다른 값을 읽게 되는 Non-Repeatable Read 문제가 발생할 수 있다.

3. Repeatable Read(반복 읽기): 한 트랜잭션이 데이터를 읽은 후 다른 트랜잭션이 해당 데이터를 수정하거나 삭제할 수 없다.
이로 인해 Non-Repeatable Read 문제는 방지되지만, 다른 트랜잭션이 새로운 데이터를 삽입하여 첫 번째 트랜잭션이 범위 조회 시 
새로운 데이터를 읽게 되는 Phantom Read 문제가 발생할 수 있다.

4. Serializable(직렬화): 가장 높은 격리 수준으로, 모든 트랜잭션이 순차적으로 실행되는 것처럼 동작한다.
이로 인해 모든 격리성 문제(Dirty Read, Non-Repeatable Read, Phantom Read)가 방지된다.
하지만 모든 트랜잭션에 대해 락이 걸리기 때문에 동시성 성능이 저하된다.
